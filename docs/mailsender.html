<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>mailutility.mailsender API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mailutility.mailsender</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import getpass
import smtplib
from typing import Union, List
from pathlib import Path
from email import encoders
from email.mime.base import MIMEBase
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.utils import formatdate
import logging

logger = logging.getLogger(__name__)


QUIT_ERROR = &#34;Fail to quit&#34;


class ConnectionFailed(Exception):
    pass


class MailSender(object):

    # noinspection PyUnresolvedReferences
    &#34;&#34;&#34;Utils to send mails, supports attaching files. Only compatible with an sending account that does not use a
        double authentification method.

    Examples
    --------

    &gt;&gt;&gt; from mailutility import MailSender  # doctest: +SKIP
    &gt;&gt;&gt; from transparentpath import TransparentPath as Tp  # doctest: +SKIP
    &gt;&gt;&gt; some_directory_path = Tp(&#34;gs://my_bucket/some_dir&#34;)  # doctest: +SKIP
    &gt;&gt;&gt; # If the password is not provided, you will asked to provide it interactively
    &gt;&gt;&gt; ms = MailSender(sender=&#34;chien@chat.com&#34;, passwd=&#34;thepasswd&#34;)  # doctest: +SKIP
    &gt;&gt;&gt; ms.test_mail_server()  # doctest: +SKIP
    &gt;&gt;&gt; ms.send_mail(  # doctest: +SKIP
    &gt;&gt;&gt;    adresses=[&#34;foo@bar.com&#34;, &#34;foo2@bar2.com&#34;],  # doctest: +SKIP
    &gt;&gt;&gt;    subject=f&#34;the mail subject&#34;,  # doctest: +SKIP
    &gt;&gt;&gt;    files=[some_directory_path / &#34;some_file_name.pdf&#34;,  # doctest: +SKIP
    &gt;&gt;&gt;           some_directory_path / &#34;some_other_file_name.csv&#34;],  # doctest: +SKIP
    &gt;&gt;&gt; )  # doctest: +SKIP

        &#34;&#34;&#34;

    hostname = &#34;outlook.office365.com&#34;
    default_mail = &#34;&#34;

    def __init__(self, sender: str = None, passwd: str = None, do_raise: bool = True):
        &#34;&#34;&#34;
        If sender or password is not specified, you will be prompted for
        them when trying to connect.

        Parameters
        ----------

        sender: str
            The username or full address of the sender. Must match a valid email account

        passwd: str
            The password matching the sender

        do_raise: bool
            If True, will raise exception. Else, log them and pass

        &#34;&#34;&#34;
        self.sender = sender
        self.passwd = passwd
        self.do_raise = do_raise
        self.smtp = None

    def set_mail_server(self) -&gt; bool:
        &#34;&#34;&#34; Will set self.smtp
        If the login and passwd are already known, just try to reconnect.
        Else, will prompt for username and passwd. If connection fails,
        will prompt again in case a typo was made, and that up to three
        times. After, will return False.

        Returns
        -------
        bool
            True if connection is successful, False if not. If self.do_raise is
            True, will not return False but will raise an error instead.

        &#34;&#34;&#34;
        if self.sender is not None and self.passwd is not None and self.smtp is not None:
            if MailSender.hostname is None:
                if self.do_raise:
                    raise ValueError(&#34;You must specify the histname attribute of MailSender (like &#34;
                                     &#34;outlook.office365.com for example)&#34;)
                logger.error(&#34;You must specify the histname attribute of MailSender (like outlook.office365.com for &#34;
                             &#34;example)&#34;)
                return False

            try:
                self.smtp = smtplib.SMTP(MailSender.hostname, port=587)
                self.smtp.connect(MailSender.hostname, 587)
                self.smtp.starttls()
                self.smtp.login(self.sender, self.passwd)
            except Exception as e:
                if self.do_raise:
                    raise e
                logger.error(e)
                return False
            return True
        else:
            if self.sender is None:
                self.sender = input(&#34;Account mail or username:\r\n&#34;)

            if &#34;@&#34; not in self.sender:
                self.sender += f&#34;@{MailSender.default_mail}&#34;
            attempt = 0
            while not self.sender.endswith(f&#34;{MailSender.default_mail}&#34;) and attempt &lt; 3:
                attempt += 1
                if attempt == 3:
                    if self.do_raise:
                        raise ConnectionFailed
                    return False
                logger.error(&#34;The address you specified is not a valid Advestis email&#34;)
                self.sender = input(&#34;email adress:\r\n&#34;)

            if self.passwd is None:
                self.passwd = getpass.getpass(&#34;Password:\r\n&#34;)

            self.smtp = None
            logged_in = False
            # Set up server
            try:
                self.smtp = smtplib.SMTP(MailSender.hostname, port=587)
                self.smtp.connect(MailSender.hostname, 587)
                self.smtp.starttls()
            except Exception as e:
                if self.do_raise:
                    raise e
                logger.error(e)
                return False
            # login to server
            attempt = 0
            while attempt &lt; 3 and not logged_in:
                try:
                    self.smtp.login(self.sender, self.passwd)
                    logged_in = True
                except Exception as e:
                    attempt += 1
                    if attempt == 3:
                        if self.do_raise:
                            raise ConnectionFailed
                        return False
                    logger.error(e)
                    logger.error(&#34;Identificatin failed. Try again!&#34;)
                    self.sender = input(&#34;email adress or username:\r\n&#34;)
                    if &#34;@&#34; not in self.sender:
                        self.sender += f&#34;@{MailSender.default_mail}&#34;
                    sub_attempt = 0
                    while not self.sender.endswith(f&#34;{MailSender.default_mail}&#34;) and sub_attempt &lt; 3:
                        sub_attempt += 1
                        if sub_attempt == 3:
                            if self.do_raise:
                                raise ConnectionFailed
                            return False
                        logger.error(&#34;The adress you specified is not a valid Advestis email&#34;)
                        self.sender = input(&#34;email adress:\r\n&#34;)
                    self.passwd = getpass.getpass(&#34;Password:\r\n&#34;)
        return True

    def test_mail_server(self) -&gt; bool:
        &#34;&#34;&#34;Tests the connection
        Calls, self.set_mail_server, so will prompt for username and passwd
        if they are not known.

        Returns
        -------
        bool
            True if connection successful, False otherwise. If self.do_raise is
            True, will not return False but will raise an error instead.

        &#34;&#34;&#34;
        logged_in = self.set_mail_server()
        if not logged_in or self.smtp is None:
            return False

        logger.info(&#34;Connection successful!\n&#34;)
        # noinspection PyBroadException
        try:
            self.smtp.quit()
        except Exception:
            logger.debug(QUIT_ERROR)
        return True

    # noinspection PyUnresolvedReferences
    def send_mail(
        self,
        adresses: Union[str, List],
        subject: str,
        text: str = &#34;&#34;,
        files: List[Union[&#34;TransparentPath&#34;, Path, str]] = None,
    ) -&gt; bool:
        &#34;&#34;&#34;Send a mail to a list of recepients. Can include files.

        Parameters
        ----------
        adresses: Union[str, List]
            One recipient or a list of recipient

        subject: str
            The mail subject

        text: str
            The mail main body

        files: List[Union[TransparentPath, Path, str]]
            The paths to the attachment to join to the mail

        Returns
        -------
        bool
            True if mail was sent to at least one recipient, else False

        &#34;&#34;&#34;

        if files is None:
            files = []
        if not isinstance(adresses, list):
            adresses = [adresses]

        # server connection can be already opened. In any case, close it
        # and reopen it.
        # noinspection PyBroadException
        try:
            self.smtp.quit()
        except Exception:
            logger.debug(QUIT_ERROR)

        if not self.set_mail_server():
            return False

        message = MIMEMultipart()
        message[&#34;From&#34;] = self.sender
        message[&#34;Date&#34;] = formatdate(localtime=True)
        message[&#34;To&#34;] = &#34;, &#34;.join(adresses)
        message[&#34;Subject&#34;] = subject
        message.attach(MIMEText(f&#34;{text}.\n\n   Sent by AdUtils&#39; MailSender.&#34;))

        # Attach files if any
        for filepath in files:
            if type(filepath) == str:
                name = Path(filepath).name
            else:
                name = filepath.name
            with open(filepath, &#34;rb&#34;) as fil:
                part = MIMEBase(&#34;application&#34;, &#34;octet-stream&#34;)
                part.set_payload(fil.read())
                encoders.encode_base64(part)
            part.add_header(&#34;Content-Disposition&#34;, f&#39;attachment; filename=&#34;{name}&#34;&#39;)
            message.attach(part)

        refused = self.smtp.sendmail(self.sender, adresses, message.as_string())
        accepted = [item for item in adresses if item not in refused]

        logger.info(&#34;Mail successfully sent to:&#34;)

        if len(accepted) == 0:
            logger.info(&#34;No one!&#34;)
            return False
        else:
            for item in accepted:
                logger.info(item)

        if len(refused) &gt; 0:
            logger.error(&#34;  Mail failed to be sent to:&#34;)
            for item in refused:
                logger.error(f&#34;{item} because {refused[item]}&#34;)
        # noinspection PyBroadException
        try:
            self.smtp.quit()
        except Exception:
            logger.debug(QUIT_ERROR)
        return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mailutility.mailsender.ConnectionFailed"><code class="flex name class">
<span>class <span class="ident">ConnectionFailed</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConnectionFailed(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="mailutility.mailsender.MailSender"><code class="flex name class">
<span>class <span class="ident">MailSender</span></span>
<span>(</span><span>sender: str = None, passwd: str = None, do_raise: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Utils to send mails, supports attaching files. Only compatible with an sending account that does not use a
double authentification method.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from mailutility import MailSender  # doctest: +SKIP
&gt;&gt;&gt; from transparentpath import TransparentPath as Tp  # doctest: +SKIP
&gt;&gt;&gt; some_directory_path = Tp(&quot;gs://my_bucket/some_dir&quot;)  # doctest: +SKIP
&gt;&gt;&gt; # If the password is not provided, you will asked to provide it interactively
&gt;&gt;&gt; ms = MailSender(sender=&quot;chien@chat.com&quot;, passwd=&quot;thepasswd&quot;)  # doctest: +SKIP
&gt;&gt;&gt; ms.test_mail_server()  # doctest: +SKIP
&gt;&gt;&gt; ms.send_mail(  # doctest: +SKIP
&gt;&gt;&gt;    adresses=[&quot;foo@bar.com&quot;, &quot;foo2@bar2.com&quot;],  # doctest: +SKIP
&gt;&gt;&gt;    subject=f&quot;the mail subject&quot;,  # doctest: +SKIP
&gt;&gt;&gt;    files=[some_directory_path / &quot;some_file_name.pdf&quot;,  # doctest: +SKIP
&gt;&gt;&gt;           some_directory_path / &quot;some_other_file_name.csv&quot;],  # doctest: +SKIP
&gt;&gt;&gt; )  # doctest: +SKIP
</code></pre>
<p>If sender or password is not specified, you will be prompted for
them when trying to connect.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sender</code></strong> :&ensp;<code>str</code></dt>
<dd>The username or full address of the sender. Must match a valid email account</dd>
<dt><strong><code>passwd</code></strong> :&ensp;<code>str</code></dt>
<dd>The password matching the sender</dd>
<dt><strong><code>do_raise</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, will raise exception. Else, log them and pass</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MailSender(object):

    # noinspection PyUnresolvedReferences
    &#34;&#34;&#34;Utils to send mails, supports attaching files. Only compatible with an sending account that does not use a
        double authentification method.

    Examples
    --------

    &gt;&gt;&gt; from mailutility import MailSender  # doctest: +SKIP
    &gt;&gt;&gt; from transparentpath import TransparentPath as Tp  # doctest: +SKIP
    &gt;&gt;&gt; some_directory_path = Tp(&#34;gs://my_bucket/some_dir&#34;)  # doctest: +SKIP
    &gt;&gt;&gt; # If the password is not provided, you will asked to provide it interactively
    &gt;&gt;&gt; ms = MailSender(sender=&#34;chien@chat.com&#34;, passwd=&#34;thepasswd&#34;)  # doctest: +SKIP
    &gt;&gt;&gt; ms.test_mail_server()  # doctest: +SKIP
    &gt;&gt;&gt; ms.send_mail(  # doctest: +SKIP
    &gt;&gt;&gt;    adresses=[&#34;foo@bar.com&#34;, &#34;foo2@bar2.com&#34;],  # doctest: +SKIP
    &gt;&gt;&gt;    subject=f&#34;the mail subject&#34;,  # doctest: +SKIP
    &gt;&gt;&gt;    files=[some_directory_path / &#34;some_file_name.pdf&#34;,  # doctest: +SKIP
    &gt;&gt;&gt;           some_directory_path / &#34;some_other_file_name.csv&#34;],  # doctest: +SKIP
    &gt;&gt;&gt; )  # doctest: +SKIP

        &#34;&#34;&#34;

    hostname = &#34;outlook.office365.com&#34;
    default_mail = &#34;&#34;

    def __init__(self, sender: str = None, passwd: str = None, do_raise: bool = True):
        &#34;&#34;&#34;
        If sender or password is not specified, you will be prompted for
        them when trying to connect.

        Parameters
        ----------

        sender: str
            The username or full address of the sender. Must match a valid email account

        passwd: str
            The password matching the sender

        do_raise: bool
            If True, will raise exception. Else, log them and pass

        &#34;&#34;&#34;
        self.sender = sender
        self.passwd = passwd
        self.do_raise = do_raise
        self.smtp = None

    def set_mail_server(self) -&gt; bool:
        &#34;&#34;&#34; Will set self.smtp
        If the login and passwd are already known, just try to reconnect.
        Else, will prompt for username and passwd. If connection fails,
        will prompt again in case a typo was made, and that up to three
        times. After, will return False.

        Returns
        -------
        bool
            True if connection is successful, False if not. If self.do_raise is
            True, will not return False but will raise an error instead.

        &#34;&#34;&#34;
        if self.sender is not None and self.passwd is not None and self.smtp is not None:
            if MailSender.hostname is None:
                if self.do_raise:
                    raise ValueError(&#34;You must specify the histname attribute of MailSender (like &#34;
                                     &#34;outlook.office365.com for example)&#34;)
                logger.error(&#34;You must specify the histname attribute of MailSender (like outlook.office365.com for &#34;
                             &#34;example)&#34;)
                return False

            try:
                self.smtp = smtplib.SMTP(MailSender.hostname, port=587)
                self.smtp.connect(MailSender.hostname, 587)
                self.smtp.starttls()
                self.smtp.login(self.sender, self.passwd)
            except Exception as e:
                if self.do_raise:
                    raise e
                logger.error(e)
                return False
            return True
        else:
            if self.sender is None:
                self.sender = input(&#34;Account mail or username:\r\n&#34;)

            if &#34;@&#34; not in self.sender:
                self.sender += f&#34;@{MailSender.default_mail}&#34;
            attempt = 0
            while not self.sender.endswith(f&#34;{MailSender.default_mail}&#34;) and attempt &lt; 3:
                attempt += 1
                if attempt == 3:
                    if self.do_raise:
                        raise ConnectionFailed
                    return False
                logger.error(&#34;The address you specified is not a valid Advestis email&#34;)
                self.sender = input(&#34;email adress:\r\n&#34;)

            if self.passwd is None:
                self.passwd = getpass.getpass(&#34;Password:\r\n&#34;)

            self.smtp = None
            logged_in = False
            # Set up server
            try:
                self.smtp = smtplib.SMTP(MailSender.hostname, port=587)
                self.smtp.connect(MailSender.hostname, 587)
                self.smtp.starttls()
            except Exception as e:
                if self.do_raise:
                    raise e
                logger.error(e)
                return False
            # login to server
            attempt = 0
            while attempt &lt; 3 and not logged_in:
                try:
                    self.smtp.login(self.sender, self.passwd)
                    logged_in = True
                except Exception as e:
                    attempt += 1
                    if attempt == 3:
                        if self.do_raise:
                            raise ConnectionFailed
                        return False
                    logger.error(e)
                    logger.error(&#34;Identificatin failed. Try again!&#34;)
                    self.sender = input(&#34;email adress or username:\r\n&#34;)
                    if &#34;@&#34; not in self.sender:
                        self.sender += f&#34;@{MailSender.default_mail}&#34;
                    sub_attempt = 0
                    while not self.sender.endswith(f&#34;{MailSender.default_mail}&#34;) and sub_attempt &lt; 3:
                        sub_attempt += 1
                        if sub_attempt == 3:
                            if self.do_raise:
                                raise ConnectionFailed
                            return False
                        logger.error(&#34;The adress you specified is not a valid Advestis email&#34;)
                        self.sender = input(&#34;email adress:\r\n&#34;)
                    self.passwd = getpass.getpass(&#34;Password:\r\n&#34;)
        return True

    def test_mail_server(self) -&gt; bool:
        &#34;&#34;&#34;Tests the connection
        Calls, self.set_mail_server, so will prompt for username and passwd
        if they are not known.

        Returns
        -------
        bool
            True if connection successful, False otherwise. If self.do_raise is
            True, will not return False but will raise an error instead.

        &#34;&#34;&#34;
        logged_in = self.set_mail_server()
        if not logged_in or self.smtp is None:
            return False

        logger.info(&#34;Connection successful!\n&#34;)
        # noinspection PyBroadException
        try:
            self.smtp.quit()
        except Exception:
            logger.debug(QUIT_ERROR)
        return True

    # noinspection PyUnresolvedReferences
    def send_mail(
        self,
        adresses: Union[str, List],
        subject: str,
        text: str = &#34;&#34;,
        files: List[Union[&#34;TransparentPath&#34;, Path, str]] = None,
    ) -&gt; bool:
        &#34;&#34;&#34;Send a mail to a list of recepients. Can include files.

        Parameters
        ----------
        adresses: Union[str, List]
            One recipient or a list of recipient

        subject: str
            The mail subject

        text: str
            The mail main body

        files: List[Union[TransparentPath, Path, str]]
            The paths to the attachment to join to the mail

        Returns
        -------
        bool
            True if mail was sent to at least one recipient, else False

        &#34;&#34;&#34;

        if files is None:
            files = []
        if not isinstance(adresses, list):
            adresses = [adresses]

        # server connection can be already opened. In any case, close it
        # and reopen it.
        # noinspection PyBroadException
        try:
            self.smtp.quit()
        except Exception:
            logger.debug(QUIT_ERROR)

        if not self.set_mail_server():
            return False

        message = MIMEMultipart()
        message[&#34;From&#34;] = self.sender
        message[&#34;Date&#34;] = formatdate(localtime=True)
        message[&#34;To&#34;] = &#34;, &#34;.join(adresses)
        message[&#34;Subject&#34;] = subject
        message.attach(MIMEText(f&#34;{text}.\n\n   Sent by AdUtils&#39; MailSender.&#34;))

        # Attach files if any
        for filepath in files:
            if type(filepath) == str:
                name = Path(filepath).name
            else:
                name = filepath.name
            with open(filepath, &#34;rb&#34;) as fil:
                part = MIMEBase(&#34;application&#34;, &#34;octet-stream&#34;)
                part.set_payload(fil.read())
                encoders.encode_base64(part)
            part.add_header(&#34;Content-Disposition&#34;, f&#39;attachment; filename=&#34;{name}&#34;&#39;)
            message.attach(part)

        refused = self.smtp.sendmail(self.sender, adresses, message.as_string())
        accepted = [item for item in adresses if item not in refused]

        logger.info(&#34;Mail successfully sent to:&#34;)

        if len(accepted) == 0:
            logger.info(&#34;No one!&#34;)
            return False
        else:
            for item in accepted:
                logger.info(item)

        if len(refused) &gt; 0:
            logger.error(&#34;  Mail failed to be sent to:&#34;)
            for item in refused:
                logger.error(f&#34;{item} because {refused[item]}&#34;)
        # noinspection PyBroadException
        try:
            self.smtp.quit()
        except Exception:
            logger.debug(QUIT_ERROR)
        return True</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="mailutility.mailsender.MailSender.default_mail"><code class="name">var <span class="ident">default_mail</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="mailutility.mailsender.MailSender.hostname"><code class="name">var <span class="ident">hostname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mailutility.mailsender.MailSender.send_mail"><code class="name flex">
<span>def <span class="ident">send_mail</span></span>(<span>self, adresses: Union[str, List], subject: str, text: str = '', files: List[Union[ForwardRef('TransparentPath'), pathlib.Path, str]] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Send a mail to a list of recepients. Can include files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>adresses</code></strong> :&ensp;<code>Union[str, List]</code></dt>
<dd>One recipient or a list of recipient</dd>
<dt><strong><code>subject</code></strong> :&ensp;<code>str</code></dt>
<dd>The mail subject</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The mail main body</dd>
<dt><strong><code>files</code></strong> :&ensp;<code>List[Union[TransparentPath, Path, str]]</code></dt>
<dd>The paths to the attachment to join to the mail</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if mail was sent to at least one recipient, else False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_mail(
    self,
    adresses: Union[str, List],
    subject: str,
    text: str = &#34;&#34;,
    files: List[Union[&#34;TransparentPath&#34;, Path, str]] = None,
) -&gt; bool:
    &#34;&#34;&#34;Send a mail to a list of recepients. Can include files.

    Parameters
    ----------
    adresses: Union[str, List]
        One recipient or a list of recipient

    subject: str
        The mail subject

    text: str
        The mail main body

    files: List[Union[TransparentPath, Path, str]]
        The paths to the attachment to join to the mail

    Returns
    -------
    bool
        True if mail was sent to at least one recipient, else False

    &#34;&#34;&#34;

    if files is None:
        files = []
    if not isinstance(adresses, list):
        adresses = [adresses]

    # server connection can be already opened. In any case, close it
    # and reopen it.
    # noinspection PyBroadException
    try:
        self.smtp.quit()
    except Exception:
        logger.debug(QUIT_ERROR)

    if not self.set_mail_server():
        return False

    message = MIMEMultipart()
    message[&#34;From&#34;] = self.sender
    message[&#34;Date&#34;] = formatdate(localtime=True)
    message[&#34;To&#34;] = &#34;, &#34;.join(adresses)
    message[&#34;Subject&#34;] = subject
    message.attach(MIMEText(f&#34;{text}.\n\n   Sent by AdUtils&#39; MailSender.&#34;))

    # Attach files if any
    for filepath in files:
        if type(filepath) == str:
            name = Path(filepath).name
        else:
            name = filepath.name
        with open(filepath, &#34;rb&#34;) as fil:
            part = MIMEBase(&#34;application&#34;, &#34;octet-stream&#34;)
            part.set_payload(fil.read())
            encoders.encode_base64(part)
        part.add_header(&#34;Content-Disposition&#34;, f&#39;attachment; filename=&#34;{name}&#34;&#39;)
        message.attach(part)

    refused = self.smtp.sendmail(self.sender, adresses, message.as_string())
    accepted = [item for item in adresses if item not in refused]

    logger.info(&#34;Mail successfully sent to:&#34;)

    if len(accepted) == 0:
        logger.info(&#34;No one!&#34;)
        return False
    else:
        for item in accepted:
            logger.info(item)

    if len(refused) &gt; 0:
        logger.error(&#34;  Mail failed to be sent to:&#34;)
        for item in refused:
            logger.error(f&#34;{item} because {refused[item]}&#34;)
    # noinspection PyBroadException
    try:
        self.smtp.quit()
    except Exception:
        logger.debug(QUIT_ERROR)
    return True</code></pre>
</details>
</dd>
<dt id="mailutility.mailsender.MailSender.set_mail_server"><code class="name flex">
<span>def <span class="ident">set_mail_server</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Will set self.smtp
If the login and passwd are already known, just try to reconnect.
Else, will prompt for username and passwd. If connection fails,
will prompt again in case a typo was made, and that up to three
times. After, will return False.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if connection is successful, False if not. If self.do_raise is
True, will not return False but will raise an error instead.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_mail_server(self) -&gt; bool:
    &#34;&#34;&#34; Will set self.smtp
    If the login and passwd are already known, just try to reconnect.
    Else, will prompt for username and passwd. If connection fails,
    will prompt again in case a typo was made, and that up to three
    times. After, will return False.

    Returns
    -------
    bool
        True if connection is successful, False if not. If self.do_raise is
        True, will not return False but will raise an error instead.

    &#34;&#34;&#34;
    if self.sender is not None and self.passwd is not None and self.smtp is not None:
        if MailSender.hostname is None:
            if self.do_raise:
                raise ValueError(&#34;You must specify the histname attribute of MailSender (like &#34;
                                 &#34;outlook.office365.com for example)&#34;)
            logger.error(&#34;You must specify the histname attribute of MailSender (like outlook.office365.com for &#34;
                         &#34;example)&#34;)
            return False

        try:
            self.smtp = smtplib.SMTP(MailSender.hostname, port=587)
            self.smtp.connect(MailSender.hostname, 587)
            self.smtp.starttls()
            self.smtp.login(self.sender, self.passwd)
        except Exception as e:
            if self.do_raise:
                raise e
            logger.error(e)
            return False
        return True
    else:
        if self.sender is None:
            self.sender = input(&#34;Account mail or username:\r\n&#34;)

        if &#34;@&#34; not in self.sender:
            self.sender += f&#34;@{MailSender.default_mail}&#34;
        attempt = 0
        while not self.sender.endswith(f&#34;{MailSender.default_mail}&#34;) and attempt &lt; 3:
            attempt += 1
            if attempt == 3:
                if self.do_raise:
                    raise ConnectionFailed
                return False
            logger.error(&#34;The address you specified is not a valid Advestis email&#34;)
            self.sender = input(&#34;email adress:\r\n&#34;)

        if self.passwd is None:
            self.passwd = getpass.getpass(&#34;Password:\r\n&#34;)

        self.smtp = None
        logged_in = False
        # Set up server
        try:
            self.smtp = smtplib.SMTP(MailSender.hostname, port=587)
            self.smtp.connect(MailSender.hostname, 587)
            self.smtp.starttls()
        except Exception as e:
            if self.do_raise:
                raise e
            logger.error(e)
            return False
        # login to server
        attempt = 0
        while attempt &lt; 3 and not logged_in:
            try:
                self.smtp.login(self.sender, self.passwd)
                logged_in = True
            except Exception as e:
                attempt += 1
                if attempt == 3:
                    if self.do_raise:
                        raise ConnectionFailed
                    return False
                logger.error(e)
                logger.error(&#34;Identificatin failed. Try again!&#34;)
                self.sender = input(&#34;email adress or username:\r\n&#34;)
                if &#34;@&#34; not in self.sender:
                    self.sender += f&#34;@{MailSender.default_mail}&#34;
                sub_attempt = 0
                while not self.sender.endswith(f&#34;{MailSender.default_mail}&#34;) and sub_attempt &lt; 3:
                    sub_attempt += 1
                    if sub_attempt == 3:
                        if self.do_raise:
                            raise ConnectionFailed
                        return False
                    logger.error(&#34;The adress you specified is not a valid Advestis email&#34;)
                    self.sender = input(&#34;email adress:\r\n&#34;)
                self.passwd = getpass.getpass(&#34;Password:\r\n&#34;)
    return True</code></pre>
</details>
</dd>
<dt id="mailutility.mailsender.MailSender.test_mail_server"><code class="name flex">
<span>def <span class="ident">test_mail_server</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tests the connection
Calls, self.set_mail_server, so will prompt for username and passwd
if they are not known.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if connection successful, False otherwise. If self.do_raise is
True, will not return False but will raise an error instead.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_mail_server(self) -&gt; bool:
    &#34;&#34;&#34;Tests the connection
    Calls, self.set_mail_server, so will prompt for username and passwd
    if they are not known.

    Returns
    -------
    bool
        True if connection successful, False otherwise. If self.do_raise is
        True, will not return False but will raise an error instead.

    &#34;&#34;&#34;
    logged_in = self.set_mail_server()
    if not logged_in or self.smtp is None:
        return False

    logger.info(&#34;Connection successful!\n&#34;)
    # noinspection PyBroadException
    try:
        self.smtp.quit()
    except Exception:
        logger.debug(QUIT_ERROR)
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mailutility" href="index.html">mailutility</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mailutility.mailsender.ConnectionFailed" href="#mailutility.mailsender.ConnectionFailed">ConnectionFailed</a></code></h4>
</li>
<li>
<h4><code><a title="mailutility.mailsender.MailSender" href="#mailutility.mailsender.MailSender">MailSender</a></code></h4>
<ul class="">
<li><code><a title="mailutility.mailsender.MailSender.default_mail" href="#mailutility.mailsender.MailSender.default_mail">default_mail</a></code></li>
<li><code><a title="mailutility.mailsender.MailSender.hostname" href="#mailutility.mailsender.MailSender.hostname">hostname</a></code></li>
<li><code><a title="mailutility.mailsender.MailSender.send_mail" href="#mailutility.mailsender.MailSender.send_mail">send_mail</a></code></li>
<li><code><a title="mailutility.mailsender.MailSender.set_mail_server" href="#mailutility.mailsender.MailSender.set_mail_server">set_mail_server</a></code></li>
<li><code><a title="mailutility.mailsender.MailSender.test_mail_server" href="#mailutility.mailsender.MailSender.test_mail_server">test_mail_server</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>